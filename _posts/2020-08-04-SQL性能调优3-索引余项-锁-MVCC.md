---
title: "SQL性能调优3-索引余项-锁-MVCC"
tags: mysql 索引 锁 MVCC
---



# 索引余项

## 索引片和过滤因子

索引片是sql查询语句执行时需要扫描的一个索引片段。

按照匹配列数的不同，可以分为：

- 窄索引（包含索引列数小于等于2）
- 宽索引（包含索引列数大于2）

### 回表

每个非聚集索引保存的数据都会同时存储主键值，查询时通过索引找到对应的主键，然后再回到数据表中，通过主键值来查找相关的数据。

#### 通过宽索引避免回表

使用宽索引将select中需要用到的列（主键可以除外）都包含在内，可以避免回表扫描，提升SQL查询效率。

### 过滤因子

在where条件语句中，每个条件都称为一个谓词，谓词的选择性等于满足这个条件列的记录数和总记录数的比例，也就是过滤因子。

联合过滤因子有更高的过滤能力，同时，联合索引中的条件列的关联性应该尽可能低，不同的条件列互相独立最好。

过滤因子的条件过滤能力越强，满足条件的记录越少，SQL查询需要扫描的索引片就越少。

## 三星索引

三星索引标准：

- 在WHERE条件语句中，将所有等值谓词的条件列作为索引片中的开始列。
- 将GROUP BY 和 ORDER BY中的列加入索引片中
- 将SELECT字段中剩余的列加入到索引片中

原理和优点（与上面三条意义对应）：

- 最小化碎片
- 避免排序
- 避免回表查询

缺点：

- 三星索引会让索引片变宽，每个页能够存储的索引数据也会变少，增加了页加载的数量。
- 如果数据量很大，过多索引需要的磁盘空间也会成为问题，缓冲池的压力也会增大。
- 全部查询都设置三星索引的话，会使数据表中的索引过多，增加了索引维护的成本。

## 合适的使用索引

- 一张表的索引个数不宜过多
- 新建索引首先考虑复合索引
- 在索引片中也要控制列的数量，一般不会采用第三星的做法。
- 索引长度需要控制，innoDB默认单个索引最大长度767bytes。如果超过这个限制，就会去前缀索引（前255个字符）。

# 数据库中的锁

## 锁的类别

### 按照锁定对象粒度划分

- 行锁，按照行记录锁定数据。开销较大，加锁较慢。
- 页锁，一页可以有多个行，锁定一页的数据，开销介于行锁和表锁之间。
- 表锁，锁定整个表，加锁开销很小，很快。
- 区锁，数据库锁，不常用。

|            | 行锁 | 页锁 | 表锁 |
| :--------: | :--: | :--: | :--: |
|   InnoDB   |  √   |      |  √   |
|   MylSAM   |      |      |  √   |
|    BDB     |      |  √   |  √   |
|   Oracle   |  √   |      |  √   |
| SQL Server |  √   |  √   |  √   |

锁也会占用空间，每个层级的锁是有限的，超过阈值将进行锁升级，用更大粒度的锁代替粒度低的锁。

### 从数据库管理角度划分

- 共享锁：读锁，S锁，被锁定的数据可以被其他用户读，但不能修改。SELECT语句会添加共享锁，读取完毕后释放。

- 排他锁：独占锁，写锁，X锁。被锁定的数据只允许进行锁定操作的业务使用，其他事务不能查询或修改。

  ```mysql
  SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE user_id = 912178 LOCK IN SHARE MODE
  ```

  INSERT，DELETE，UPDATE查询自动使用排他锁。

- 意向锁：向更大一级的空间示意内部已经上锁。一般意向锁的添加是数据库自动执行的。

### 从设计原则划分

- 乐观锁：乐观的认为对同一数据的并发操作不会总发生，不用每次都上锁。不适用数据库提供的锁，而是通过程序实现锁。
- 悲观锁：对数据被其他事务修改持保守态度，通过数据库本身的锁机制实现数据操作的排他性。

#### 乐观锁的实现

乐观锁有很多种实现方式：

##### 版本号机制

在表中添加一个version版本字段，第一次读的时候，获取该字段的值，更新操作时，执行：

```mysql
UPDATE ... SET version=version+1 WHERE version=version
```

如果这期间有其他事务对该数据进行了修改，那么这次修改就不会成功。

##### 时间戳机制

和版本号类似，添加最后修改的时间戳，避免冲突。

#### 性质

- 乐观锁适合读较多的场景，通过程序实现，数据库层面不存在死锁问题，但并不影响程序之外的数据库操作。
- 适合写较多的场景，在数据库层面阻止其他事务的数据操作活动，放置出现读写冲突和写入冲突。

# MVCC

##### 回顾事务的隔离级别：

|           级别            |  解决异常  |
| :-----------------------: | :--------: |
|         读已提交          |   啥也没   |
|         读已提交          |    脏读    |
| 可重复度（mysql默认级别） | 不可重复读 |
|          串行化           |    幻读    |

MVCC:Multiversion Concurrency Control，多版本并发控制技术。通过数据库的多个版本来实现并发控制。

功能：

- 解决读写之间阻塞的问题。使得读写互不阻塞，提高事务并发处理能力。
- 降低死锁概率，MVCC采用乐观锁机制，读不锁，写锁行。
- 解决一致性问题。即快照读。

##### 快照读和当前读

不加锁的简单SELECT都属于快照读。

当前读读取最新数据，加锁的SELECT或增删改操作都会执行当前读。

## InnoDB中的MVCC实现

### 行记录的隐藏列

InnoDB的叶子节点段存储数据页，数据页存储行记录，行记录中有重要的隐藏字段。

|    字段     | 含义                                                         |
| :---------: | :----------------------------------------------------------- |
|  db_row_id  | 隐藏的行ID，用于生成默认聚集索引，如果建表时没有创建聚集索引，InnoDB将用这个隐藏ID来创建。 |
|  db_trx_id  | 操作这个数据的最新的事务ID                                   |
| db_roll_ptr | 回滚指针，指向这个记录的Undo Log信息。                       |

![img](https://static001.geekbang.org/resource/image/47/81/4799c77b8cdfda50e49a391fea727281.png)

InnoDB将行记录快照保存在Undo Log中，在回滚段，将数据行的所有快照，通过链表的结构串联起来。

### Read View

Read View解决了行的可见性问题，它保存了当前事务开启时所有活跃（未提交）的事务列表。即对当前事务来说不可见的其他事务列表。

属性：

- trx_ids，系统当前正在活跃的事务ID集合。
- low_limit_id，活跃的事务中的最大的ID。
- up_limit_id，活跃的事务中的最小的OD。
- creator_trx_id，创建Read View的事务ID。

当一个事务id_1读取某个行记录时，该行记录的事务ID为id_2，有这么几种情况：

- id_2<up_limit_id，说明行记录在这些活跃事务之前就已经提交了，该行记录对事务id_1可见。
- id_2>low_limit_id，说明该行记录在这些活跃事务创建后创建，对id_1不可见。
- up_limit_id<id_2<low_limit_id，说明id_2在id_1事务查询时可能处于活跃状态，若其在trx_ids列表中，说明其未提交，不可见。若不在trx_ids列表中，说明该事务已提交，可见。

MVCC下的读取流程：

- 获取事务自己的ID。
- 获取Read View。
- 查询得到的数据，按照上面的规则检查是否可见。
- 可见即通过，若不可见，去Undo Log中获取符合的历史快照
- 返回符合规则的数据。

PS：读已提交级别下，一个事务中的每一个SELECT都获取一次Read View，可重复读级别下，一个事务只在第一次操作获取一次Read View，后面的操作复用该Read View。

### Next-Key锁和幻读

幻读产生：在事务id_1执行时，若id_2插入了一条符合id_1要求的数据，通过Read View，事务id_1并不会发现id_2插入了一条数据，但是若id_1执行了删除或更新操作，将会覆盖掉对应记录上id_2的事务ID，若id_1执行插入一条和id_2插入的主键相同的数据，将会报错。因此，Read View并不能认为完全解决了幻读问题。

想彻底解决幻读问题，还是得靠锁。

Inno三种行锁：

- 记录锁：锁单个记录。
- 间隙锁：锁住记录到记录的一个范围，不包括记录本身，可以放置幻读产生。
- Next-key锁：锁住一个范围，包括两端记录，可以解决幻读问题。

可重复读级别下，InnoDB将会使用next-key锁解决幻读问题。

